// FAUST standard library
import("stdfaust.lib");
// THIS library
SIG = library("LSSIG.lib");

/*
Generic Signal Processing Library for DSP:
- Generation of signals (oscillators,lfo...)
- Processing of signals (waveshaping,distortion...)
*/

// Wrap = Rescale the Int Part of the Signal
Wrap(x)=x-int(x);

// Wrap function (offset: treshold 0.0 to 1.0 and then rescale INT Part)
OffsetWrap(offset,x) = (x+offset)-int(x);

// Dirac Impulse Train 0-1 (F = frequency)
Trainpulse(F) = (F/ma.SR:(+:Wrap)~ _):((((_*-1)+1)-0.5)>0)<:((_-(_:mem ))>0);

// Sample and Hold: input --> sah(control sig)
        sah(x) = sahf
            with{trigger = (((x*-1+1)-0.5)>0)-((((x*-1+1)-0.5)>0):mem)>0;
                sahf(y) = (*(1-trigger) + (y*trigger))~ _;};

// Wavefolding (g = gain, Sig)= waveshaper : saturator via Triangular Tabulation.
Wavefolding(g,x) = (x*(g/2)) <: ((_>0)*(_) <: (_<+0.5)*(_) + ((_>+0.5)*((_*-1)+1))),
                   ((_<0)*(_) <: (_>-0.5)*(_) + ((_<-0.5)*((_*-1)-1))) :> + : _*2;

// Phasor (f=frequency).
Phasor(f) = (f/ma.SR):(+ <: _-int(_))~_ ;

// Phasor with two outs: 0° and 180°. (f=frequency)
Phasor180wrap(f) = (f/ma.SR)<:(ro.interleave(2,2):(+,+)<: xywrap)~ si.bus(2)
    with{xywrap(x,y)= (x-int(x)),((y+0.5)-int(y));};

Peakholdcond = abs : circuit : false
with{
    false(a,b) = ((1-b) : _*(a:mem) : (+ : _*(1-b))~_) + a;
    circuit(x) = ((x)>(x:mem)) <: ((_*x ), _);
    };
 
Trainpulse(F) = (+(1) : %(ma.SR/F))~ _ <: (_ < (_:mem));
