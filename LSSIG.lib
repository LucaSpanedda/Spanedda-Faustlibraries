// FAUST standard library
import("stdfaust.lib");
// THIS library
SIG = library("LSSIG.lib");


/*
Generic Signal Processing Library for DSP:
- Generation of signals (oscillators,lfo...)
- Processing of signals (waveshaping,distortion...)
*/

// Dirac Impulse value based on ADC status at Compile Time
ADCDirac = (1-(1:mem))*_ : (_*1000000000) : abs : Wrap;

// Constant value based on ADC status at Compile Time
ADCConstant = ADCDirac : +~_;

// decimal function
decimal(x) = x-int(x); 
// selector between 0 and 1 state
selector(sel,x,y) = (x*(1-sel)+y*(sel));
// phasor to impulse 
ph2pulse(x) = (x < x') + (1 - 1');
// Wrap = Rescale the Int Part of the Signal
Wrap(x)=x-int(x);

// 1 when the Derivate part of the signal becomes negative
Derivative(x)=x<(x:mem);

// SAH with Phasor
SAH(ph,y) = loop~_
    with{
        ph2pulse(x) = (x < x') + (1 - 1');
        impulse = ph : ph2pulse;
        loop(fb) = selector(impulse,fb,y);
    };
// SAH with internal trigger
SAH2(freq,y) = loop~_
    with{
        decimal(x) = x-int(x); 
        selector(sel,x,y) = (x*(1-sel)+y*(sel));
        ph2pulse(x) = (x < x') + (1 - 1');
        phasor(f) = (f/ma.SR):(+ :\(x).(selector(0,x,0)) : decimal)~_ ;
        impulse(f) = phasor(f) : ph2pulse;
        loop(fb) = selector(impulse(freq),fb,y);
    };

// Wavefolding (g = gain, Sig)= waveshaper : saturator via Triangular Tabulation.
Wavefolding(g,x) = (x*(g/2)) <: ((_>0)*(_) <: (_<+0.5)*(_) + ((_>+0.5)*((_*-1)+1))),
                   ((_<0)*(_) <: (_>-0.5)*(_) + ((_<-0.5)*((_*-1)-1))) :> + : _*2;

// RANDOM GENERATOR : Change the seed value for generate a different random number
Randomseed(seed)  = ((seed*(1103515245)))/2147483647.0; 

// NOISE GENERATOR : for Every Seed a new Noise Stream
Noiseed(seed) = (+(seed)~*(1103515245))/(2147483647.0);

// NOISE GENERATOR F : with variable frequency and seed
NoiseFreq(f,seed) = Noiseed(seed) : SAH(Phasor(f));

// NOISE GENERATOR with variable frequency and seed in BIT values
NoiseFreqBit(f,seed) = (Noiseed(seed) : SAH(Phasor(f))>0)*2-1;

// NOISE BIT : noise 0 or 1
NoiseBit(seed) = (+(seed)~*(1103515245))/(2147483647.0)>0;

// NOISE Impulse Train - F
Noisepulse(F,seed) = Trainpulse(F)*Noiseed(seed);

// NOISE Impulse Train in BIT values - F
NoisepulseBit(F,seed) = Trainpulse(F)*Noiseed(seed)>0;

// BROWNIAN F : noise produced by Brownian motion, alternative name of random walk
BrownianF(f,noisef,seed) = ((f/ma.SR)*NoiseFreqBit(noisef,seed):(+ :Wrap)~_):Wavefolding(2);

phasor(f) = (f/ma.SR):(+ :\(x).(selector(0,x,0)) : decimal)~_ ;
phreset(f,trig) = (f/ma.SR):(+ :\(x).(selector(trig,x,0)) :\(x).(x-int(x)))~_ ;
impulse(f) = phasor(f) : ph2pulse;

// Phasor with Phase Jitter
PhasorJitter(F,Fjitter,seed) = (Phasor(F)+(NoiseFreq(Fjitter,seed):abs)):Wrap;

// Phasor with two outs: 0° and 180°. (f=frequency)
Phasor180wrap(f) = (f/ma.SR)<:(ro.interleave(2,2):(+,+)<: xywrap)~ si.bus(2)
    with{xywrap(x,y)= (x-int(x)),((y+0.5)-int(y));};

// Virtual Analog Sine Oscillator
VASine(F) = sin(Phasor(F)*2*ma.PI);

// Virtual Analog Sine Oscillator with Phase Jitter
VASineJitter(F,Fjitter,seed) = sin(PhasorJitter(F,Fjitter,seed)*2*ma.PI);

// Wrap function (offset: treshold 0.0 to 1.0 and then rescale INT Part)
OffsetWrap(offset,x) = (x+offset)-int(x);

// Transform an input Signal to a Trainpulse 1 Sample
SigtoPulse1(x) = (((x:abs)<0.5)<:_<(_:mem));

// Transform an input Signal to a Digital KICK Percussion
SigtoKICK(Amp,Decay,x) = sin(circuit)
    with{
        circuit = (x:SigtoPulse1)*Amp:(+ : _*Decay)~ _;
        };
