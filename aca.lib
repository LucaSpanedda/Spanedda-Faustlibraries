// THIS library
raca = library("raca.lib");
// Faust Standard Library
import("stdfaust.lib");

/*
Audio Content Analysis in Realtime Library
*/


//----------------------------------------------------------------- MAX PEAK ---
// Peak Max with IIR filter and max comparison
peakmax = _ : abs <: loop ~_
with{
    loop(x) = ((_ , x) : max);
    };
//process = _ : peakmax;

//--------------------------------------------------- PEAK ENVELOPE FOLLOWER ---
/*
reference : 
https://www.dariosanfilippo.com/blog/2017/
lookahead-limiting-in-pure-data/
reference : 
https://www.cs.princeton.edu/courses/archive/spr05/cos579/DSP/DSP.html
*/
peakenvelope(t60,x) = abs(x) <: loop ~ _ * rt60(t60)
    with{
        loop(y,z) = ( (y,z) : max);
        rt60(t) = 0.001^((1/ma.SR)/t);
    };
//process = peakenvelope(10);

//----------------------------------------------------------- MOVING AVERAGE ---
movingAverage(seconds, x) = x - (x @ N) : fi.pole(1.0) / N
    with {
        N = seconds * ma.SR;
    };
movingAverageRMS(seconds, x) = sqrt(max(0, movingAverage(seconds, x * x)));
// process = movingAverageRMS(1);

//----------------------------------------------------------- AD RMS AVERAGE ---
/*
RMS with indipendent attack and release time:
reference:
Udo ZÃ¶lzer - Digital Audio Signal Processing Second Edition
reference :
https://fmipa.umri.ac.id/wp-content/uploads/2016/03/
Udo-Zolzer-digital-audio-signal-processing.9780470997857.40435.pdf
*/
RMS(att,rel,x) = loop ~ _ : sqrt
    with {
        loop(y) = (1.0 - coeff) * x * x + coeff * y
            with {
                attCoeff = exp(-2.0 * ma.PI * ma.T / att);
                relCoeff = exp(-2.0 * ma.PI * ma.T / rel);
                coeff = ba.if(abs(x) > y, attCoeff, relCoeff);
            };
    };
// process = RMS(1,1);

//-------------------------------------------------------------- PEAK HOLDER ---
/* 
peakHolder(secondsPeriod, x) = y
    letrec {
        'y = ba.if(reset, abs(x), max(y, abs(x)));
    }
        with {
            reset = os.phasor(1, 1.0 / secondsPeriod) : \(x).(x < x');
        };
*/
// holdTime in Seconds
peakHolder(holdTime, x) = loop ~ si.bus(2) : ! , _
    with {
        loop(timerState, outState) = timer , output
            with {
                isNewPeak = abs(x) >= outState;
                isTimeOut = timerState >= (holdTime * ma.SR - 1);
                bypass = isNewPeak | isTimeOut;
                timer = ba.if(bypass, 0, timerState + 1);
                output = ba.if(bypass, abs(x), outState);
            };
    };
//process = _ : peakHolder(2);

//------------------------------------------------------- LOOKAHEAD LIMITING ---
/*
reference : 
https://www.dariosanfilippo.com/blog/2017/
lookahead-limiting-in-pure-data/
reference : 
https://users.iem.at/zmoelnig/publications/limiter/
*/
lookAheadLimiting(threshold,x) =    (x : peakHolder(.1) : LPTPT(500) : 
                                    peakenvelope(.1)) :
                                    threshold / max(ma.EPSILON, _) : min(1.0) *
                                    (x @ (ms2samp(2)));
//process = os.osc(440) * 1000 : lookAheadLimiting(.5);

//------------------------------------------------------------ PITCH TRACKER ---
// averaging function with 2pi time constant; t is the averaging time in seconds
avg(t, x) = y
    letrec {
        'y = x + alpha * (y - x);
    }
        with {
            alpha = exp((-2.0 * ma.PI * ma.T) / t);
        };

// zero-crossing indicator function
zeroCrossing(x) = (x * x') < 0;

// zero-crossing rate
zeroCrossingRate(t, x) = zeroCrossing(x) : avg(t);

// pitch tracker as zero-crossing rate of self-regulating lowpassed inputs
// we highpass the input to avoid infrasonic components to affect the measurements
// we then clip the lowpass cutoff to improve stability
pitchTracker(t, x) = loop ~ _
    with {
        loop(y) = fi.lowpass(4, max(80, y), xHighpassed) : (zeroCrossingRate(t) * ma.SR * .5) 
            with {
                xHighpassed = fi.highpass(1, 20, x);
            };
    };
//process = os.osc(1000) : pitchTracker(.5);
