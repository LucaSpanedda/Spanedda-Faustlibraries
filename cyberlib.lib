declare name "cyberlib";
declare author "Luca Spanedda";
declare version "1.0";
declare description "Luca Spanedda's Cybersonic Library";
// import faust standard library
import("stdfaust.lib");


//------- ------------- ----- -----------
//-- CYBERLIB : LUCA SPANEDDA'S CYBERSONIC LIBRARY -----------------------------
//------- --------


//--------------------------------------------------------------------- BASIC --

// limit function for library and system
limit(maxl, minl, x) = max(minl, min(maxl, x));

// milliseconds to samples
ms2samp(t) = (t / 1000) * ma.SR;

// seconds to samples
sec2samp(t) = t * ma.SR;

// only decimal pass
decimal(x) = x-int(x);

// only integer pass
integer(x) = int(x);

// shift in phase (0 to 1) and give only the fractional part of x
wrap(shift, x) = ((x + shift) : \(y).(y - int(y)));

// binary selector 0 - 1
selector(sel, x, y) = ( x * (1 - sel) + y * (sel) );

//------------------------------------------------------------------ SIGNALS --

// pseudo-random noise with linear congruential generator (LCG)
noise(initSeed) = LCG ~ _ : (_ / m)
with{
    // initSeed = an initial seed value
    a = 18446744073709551557; // a large prime number, 
        // such as 18446744073709551557
    c = 12345; // a small prime number, such as 12345
    m = 2 ^ 31; // 2.1 billion
    // linear_congruential_generator
    LCG(seed) = ((a * seed + c) + (initSeed - initSeed') % m);
};

// classic phasor
phasor(f) = (f / ma.SR) : (+ : decimal) ~ _ ;

// phasor with phase reset
phasorPH(f, trig) = (f / ma.SR) : 
    (+ : \(x).(selector(trig, x, 0)) : \(x).(x - int(x)) )~_ ;

// phasor with scattering of the phase when triggered (out 1),
// and splice of the phase = the trigger dimension (out 2)
splicePH(fph, fsah, seed, width) = 
    abs( SAH( (1 - pwm(fsah, width)) , 
    noise(seed)) ) + 
        phasor(fph) : decimal <: _, _ * pwm(fsah, width); 

// outputs: classic, PWM
splicephasor(fph, fsah, seed) = splicePH(fph, fsah, seed, .5) : _, !;
splicepwm(fph, fsah, seed, width) = splicePH(fph, fsah, seed, width) : !, _;

// unipolar  PWM 
pwm(f, wm) = phasor(f) < max(0, min(1, wm));


//----------------------------------------------------------------- WAVESHAPE --

// softclipping via hyperbolic tangent function
saturator(lim, x) = lim * ma.tanh(x / (max(lim, ma.EPSILON)));

// triangular function
triangularFunc(x) = abs(ma.frac((x - .5)) * 2.0 - 1.0);

// triangle oscillator
triangleWave(f) = triangularFunc(os.phasor(1,f));


//------------------------------------------------------------------ FILTERS ---

// SVFTPT filter function
// TPT version of the SVF Filter by Vadim Zavalishin
// reference : (by Will Pirkle)
// http://www.willpirkle.com/Downloads/AN-4VirtualAnalogFilters.2.0.pdf
SVFTPT(K, Q, CF, x) = circuitout : ! , ! , _ , _ , _ , _ , _ , _ , _ , _
with{
    g = tan(CF * ma.PI / ma.SR);
    R = 1.0 / (2.0 * Q);
    G1 = 1.0 / (1.0 + 2.0 * R * g + g * g);
    G2 = 2.0 * R + g;
    circuit(s1, s2) = u1 , u2 , lp , hp , bp, notch, apf, ubp, peak, bshelf
        with{
            hp = (x - s1 * G2 - s2) * G1;
            v1 = hp * g;
            bp = s1 + v1;
            v2 = bp * g;
            lp = s2 + v2;
            u1 = v1 + bp;
            u2 = v2 + lp;
            notch = x - ((2*R)*bp);
            apf = x - ((4*R)*bp);
            ubp = ((2*R)*bp);
            peak = lp -hp;
            bshelf = x + (((2*K)*R)*bp);
        };
    // choose the output from the SVF Filter (ex. bshelf)
    circuitout = circuit ~ si.bus(2);
};

// Zavalishin's SVF BP FILTER
// optimized BP from the TPT version of the SVF Filter by Vadim Zavalishin
// reference : (by Will Pirkle)
// http://www.willpirkle.com/Downloads/AN-4VirtualAnalogFilters.2.0.pdf
BPSVF(glin, bw, cf, x) = loop ~ si.bus(2) : (! , ! , _)
    with {
        g = tan(cf * ma.PI * (1.0/ma.SR));
        Q = cf / max(ma.EPSILON, bw);
        R = 1.0 / (Q + Q);
        G = 1.0 / (1.0 + 2.0 * R * g + g * g);
        loop(s1, s2) = u1 , u2 , bp * glin
            with {
                bp = (g * (x - s2) + s1) * G;
                bp2 = bp + bp;
                v2 = bp2 * g;
                u1 = bp2 - s1;
                u2 = v2 + s2;
            };
    };

// Zavalishin Onepole TPT Filter
// TPT version of the One-Pole Filter by Vadim Zavalishin
// reference : (by Will Pirkle)
// http://www.willpirkle.com/Downloads/AN-4VirtualAnalogFilters.2.0.pdf
onePoleTPT(cf, x) = loop ~ _ : ! , si.bus(3)
    with {
        g = tan(cf * ma.PI * ma.T);
        G = g / (1.0 + g);
        loop(s) = u , lp , hp , ap
            with {
            v = (x - s) * G; u = v + lp; lp = v + s; hp = x - lp; ap = lp - hp;
            };
    };

// Lowpass  TPT
LPTPT(cf, x) = onePoleTPT(cf, x) : (_ , ! , !);
// Highpass TPT
HPTPT(cf, x) = onePoleTPT(cf, x) : (! , _ , !);
// Allpass TPT
APTPT(cf, x) = onePoleTPT(cf, x) : (!, !, _);

// IIR OnePole Filter
OPF(CF, x) = circuit ~ _
    with{
        g(x) = x / (1.0 + x);
        G = tan(CF * ma.PI / ma.SR):g;
        circuit(y) = x * G + (y * (1 - G));
        };

OPFtau(tau, x) = fb ~ _ 
with {  
    fb(y) = (1.0 - s) * x + s * y; 
    s = exp(-1.0/(tau * ma.SR));
    //   tau = desired smoothing time constant in seconds
};


//---------------------------------------------------------------- ANALYZERS ---

// SAH circuit
SAH(ph, y) = \(FB).( selector( ph : \(x).(x < x'), FB, y ) ) ~ _ ;

// SAH circuit with internal trigger
SAH2(f, y) = \(FB).( selector( phasor(f) : \(x).(x < x'), FB, y ) ) ~ _ ;

// SAH circuit with Onepole filter for smooth (internal trigger)
SAHsmooth(f, smooth, x) =  OPF(f/smooth, x : SAH2(f));

// Unipolar SAH circuit with Onepole filter for smooth (internal trigger)
SAHsmoothuni(f, smooth, x) =  OPF(f/smooth, abs(x) : SAH2(f));

// analyze after the window
localMax(seconds, x) = loop ~ si.bus(4) : _ , ! , ! , !
with {
    loop(yState, timerState, peakState, timeInSamplesState) = 
        y , timer , peak , timeInSamples
    with {
        timeInSamples = ba.if(reset + 1 - 1', limit(1000, 0, seconds) * 
            ma.SR, timeInSamplesState);
        reset = timerState >= (timeInSamplesState - 1);
        timer = ba.if(reset, 1, timerState + 1);
        peak = max(abs(x), peakState * (1.0 - reset));
        y = ba.if(reset, peak', yState);
    };
};

// analyze new peaks
peakHolder(holdTime, x) = loop ~ si.bus(2) : ! , _
with {
    loop(timerState, outState) = timer , output
    with {
        isNewPeak = abs(x) >= outState;
        isTimeOut = timerState >= (holdTime * ma.SR - 1);
        bypass = isNewPeak | isTimeOut;
        timer = ba.if(bypass, 0, timerState + 1);
        output = ba.if(bypass, abs(x), outState);
    };
};

// RMS with indipendent attack and release time:
// reference:
// Udo ZÃ¶lzer - Digital Audio Signal Processing Second Edition
// reference :
// https://fmipa.umri.ac.id/wp-content/uploads/2016/03/
// Udo-Zolzer-digital-audio-signal-processing.9780470997857.40435.pdf
RMS(att, rel, x) = loop ~ _ : sqrt
with {
    loop(y) = (1.0 - coeff) * x * x + coeff * y
    with {
        attCoeff = exp(-2.0 * ma.PI * (1.0/ma.SR) / att);
        relCoeff = exp(-2.0 * ma.PI * (1.0/ma.SR) / rel);
        coeff = ba.if(abs(x) > y, attCoeff, relCoeff);
    };
};

// Moving Average RMS
movingAverage(seconds, x) = x - (x @ N) : fi.pole(1.0) / N
with{
    N = seconds * ma.SR;
};
RMSRectangular(seconds, x) = sqrt(max(0, movingAverage(seconds, x * x)));

// Fixed Peak Normalization
fixedNorm(x) = 1 / (x : loop ~ _) * x
with{
    loop(y,z) = ( (y, abs(z) ) : max);
};

// Fixed Peak Normalization with tau Decay
peakNorm(tau, x) = 1 / peakenvelope(tau, x) * x;

// Peak Envelope (envelope follower)
// reference :
// https://www.dariosanfilippo.com/blog/2017/
// lookahead-limiting-in-pure-data/
// reference :
// https://www.cs.princeton.edu/courses/archive/spr05/cos579/DSP/DSP.html
peakenvelope(t, x) = abs(x) <: loop ~ _ * rt60(t)
with{
    loop(y,z) = ( (y, z) : max);
    rt60(t) = 0.001^((1/ma.SR)/t);
};

// peak-hold module with an exponential decay curve
peakHoldwDecay(holdSeconds, frequencyCut, decayT60, x) = x : 
    peakHolder(holdSeconds) : LPTPT(frequencyCut) : peakenvelope(decayT60);

// lookahead limiter
// reference :
// https://www.dariosanfilippo.com/blog/2017/
// lookahead-limiting-in-pure-data/
// reference :
// https://users.iem.at/zmoelnig/publications/limiter/
// Peak normalization
// reference :
// https://www.hackaudio.com/digital-signal-processing/amplitude/peak-normalization/
lookaheadNormalization(treshold, x) = treshold / ( x : peakHoldwDecay(.1, 500, 10) ) *
    x @ (( 2/1000 ) * ma.SR);

lookaheadLimiter(threshold, x) = ( x : peakHoldwDecay(.1, 500, 10) ) : 
    ( threshold / max(ma.EPSILON, _) : min(1.0) ) *
        (x @ (ms2samp(1)));


//----------------------------------------------------------- NONLINEARITIES ---

// SAH circuit with filters smooth (internal trigger)
nonlinearsah(f, x) =  OPF(f, OPF(f, OPF(f, x : SAH2(f))));

// Unipolar SAH circuit with filters smooth (internal trigger)
nonlinearsahuni(f, x) =  OPF(f, OPF(f, OPF(f, abs(x) : SAH2(f))));

// input to nonperiodic osc
nonlinearity(f, x) = x + (ma.EPSILON - ma.EPSILON') : 
    LPTPT(f) : LPTPT(f) : fixedNorm; 