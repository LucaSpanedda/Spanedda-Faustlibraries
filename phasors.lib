import("main.lib");

// constant sample rate value
SR = ma.SR;
// binary selector 0 - 1
SELEC(sel, x, y) = (x * (1 - sel) + y * (sel));
// signal signum
SIGN(x) = (x > 0) - (x < 0);
// derivative
DR(x) = x < x';
// dirac impulse
DI = 1 - 1';

// a classic sample and hold
sah(x, t) = SELEC(t, _, x)~ _ ;

// random sample and hold function
randomsah(minF, maxF, y) = out ~ _ with{
    out(x) =    (minF, abs(x * (maxF - minF))) :> 
                phasor0 : DR : (_ + DI, x, y) : SELEC;
};

// phasor : every cycle start from 0
phasor0(f)   =  int ~  (_ + 1') % (SR / f) : _ * f : _ / SR;

// phasor with offset function
phasorOffset(f, off)  =  int ~  (_ + 1') % (SR / f) : _ * f : (_ + (off * SR)) % SR / SR;

// phasor with random reverse
phasorRevers(f, minSF, maxSF, seed) =   int ~  (_ + 1' * 
                                        (randomsah(minSF, maxSF, noise(seed)) : SIGN)) % 
                                        (SR / f) : _ * f : _ / SR : abs;

// phasor with random splicing and jumps
phasorSplice(f, minSF, maxSF, seed) =   phasorOffset(1, 
                                        abs(randomsah(minSF, maxSF, noise(seed))));

// phasor : update frequency at every cycle
phasorTF(frequency) = phasor0 ~ sahTF(fl) with{
    l(mxl, mnl, x) = max(mnl, min(mxl, x));
    fl = l(20000, .01, frequency);
    sahTF(x, ts) = SELEC(DR(ts) + DI, _, x) ~ _;
};