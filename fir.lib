// THIS library
fir = library("fir.lib");
// Luca Spanedda's Standard Faust Libraries
import("stdls.lib");

/*
Filters Library
*/

//-------------------------------------- SMOOTHING FILTER (IIR di I° Ordine) ---
// smooth function (Onepole Filter)
smooth(G) = *(1-G) : +~*(G);

//---------------------------------------- ONEZERO FILTER (FIR di I° Ordine) ---
// (G,x) = x=input, G=give amplitude 0-1(open-close) to the delayed signal
OZF(G,x) = (x:mem*G), x :> +;
// test:
//process = no.noise : OZF(0.1);

//---------------------------------------- ONEPOLE FILTER (IIR di I° Ordine) ---
OPF(CF,x) = OPFFBcircuit ~ _
    with{
        g(x) = x / (1.0 + x);
        G = tan(CF * ma.PI / ma.SR):g;
        OPFFBcircuit(y) = x*G+(y*(1-G));
        };
// test:
//process = no.noise : OPF(2000);

//---------------------------------------- ONEPOLE FILTER TPT ------------------
// TPT version of the One-Pole Filter by Vadim Zavalishin
// reference : (by Will Pirkle)
// http://www.willpirkle.com/Downloads/AN-4VirtualAnalogFilters.2.0.pdf
// Zavalishin Onepole TPT Filter
onePoleTPT(cf, x) = loop ~ _ : ! , si.bus(3)
    with {
        g = tan(cf * ma.PI * ma.T);
        G = g / (1.0 + g);
        loop(s) = u , lp , hp , ap
            with {
            v = (x - s) * G; u = v + lp; lp = v + s; hp = x - lp; ap = lp - hp;
            };
    };
// Lowpass  TPT
LPTPT(cf, x) = onePoleTPT(cf, x) : (_ , ! , !);
// Highpass TPT
HPTPT(cf, x) = onePoleTPT(cf, x) : (! , _ , !);
// Allpass TPT
ALLPASSTPT(cf, x) = onePoleTPT(cf, x) : (!, !, _);
// test:
//process = no.noise : HPTPT(100);

//-------------------------------------------------------------- TPT SVF -------
// TPT version of the SVF Filter by Vadim Zavalishin
// reference : (by Will Pirkle)
// http://www.willpirkle.com/Downloads/AN-4VirtualAnalogFilters.2.0.pdf
// SVFTPT filter function

SVFTPT(K, Q, CF, x) = circuitout : !,!,_,_,_,_,_,_,_,_
    with{
        g = tan(CF * ma.PI / ma.SR);
        R = 1.0 / (2.0 * Q);
        G1 = 1.0 / (1.0 + 2.0 * R * g + g * g);
        G2 = 2.0 * R + g;

        circuit(s1, s2) = u1 , u2 , lp , hp , bp, notch, apf, ubp, peak, bshelf
            with{
                hp = (x - s1 * G2 - s2) * G1;
                v1 = hp * g;
                bp = s1 + v1;
                v2 = bp * g;
                lp = s2 + v2;
                u1 = v1 + bp;
                u2 = v2 + lp;
                notch = x - ((2*R)*bp);
                apf = x - ((4*R)*bp);
                ubp = ((2*R)*bp);
                peak = lp -hp;
                bshelf = x + (((2*K)*R)*bp);
            };
    // choose the output from the SVF Filter (ex. bshelf)
    circuitout = circuit ~ si.bus(2);
    };
// Instructions:
// Outs = (lp , hp , bp, notch, apf, ubp, peak, bshelf)
// SVFTPT(K, Q, CF, x) = (Filter-K, Filter-Q, Frequency Cut)

// Filters Bank
LPSVFTPT(CF, x) =   SVFTPT(0 : ba.db2linear, 0 : ba.db2linear, CF, x) :
                    _,!,!,!,!,!,!,!;
HPSVFTPT(CF, x) =   SVFTPT(0 : ba.db2linear, 0 : ba.db2linear, CF, x) :
                    !,_,!,!,!,!,!,!;
BPSVFTPT(BW, CF, x) = SVFTPT(0 : ba.db2linear, Q, CF, x) : !,!,_,!,!,!,!,!
        with{
            Q = CF / BW;
            };
//process = no.noise : LPSVFTPT(((os.osc(2)+1)/2)*400);

//-------------------------------- FEEDFORWARD COMB FILTER (FIR of N° Order) ---
// (t,g) = delay time in samples, filter gain 0-1
FFCF(t,g) = _ <: ( _@(t-1) *g), _ :> _;
// test:
//process = no.noise : FFCF(100, 0.9) <: _,_;

//---------------------------------- FEEDBACK COMB FILTER (IIR di N° Ordine) ---
// (Del,G) = DEL=delay time in samples. G=feedback gain 0-1
FBCF(Del,G,x) = x:(+ @(Del-1)~ *(G)):mem;

FBComb(Del,G,x) = FBcircuit ~ _
    with {
        FBcircuit(y) = x+y@(Del-1)*G;
    };
// test:
//process = (1-1') : FBComb(1000,0.998);

//---------------------------------------------------------------- T LFBComb ---
LFBCombT(Del,G,CF) = LFBCcircuit ~ _
    with{
        LFBCcircuit(y,z) = z+(LowpassTPT(y)@(Del-1))*G
            with{
                LowpassTPT(x) = (lowpasscircuit ~ _ : ! , _)
                    with{
                        g = tan(CF * ma.PI / ma.SR);
                        G = g / (1.0 + g);
                        lowpasscircuit(sig) = u , lp
                            with{
                                v = (x - sig) * G;
                                u = v + lp;
                                lp = v + sig;
                                };
                        };
                };
        };
// test:
//process = (1-1') : LFBCombTPT(1000,0.998,10000);

//----------------------------------- ALLPASS FILTER (FIR + IIR COMB FILTER) ---
// (t,g) = give: delay in samples, feedback gain 0-1
APF(Del,G,x) = x:(+: _<: @(Del-1), *(G))~ *(-G):mem, _ : + : _;
// test:
//process = (1-1') : APF(420, 0.9);

//-------------------------------------------------------------- BUTTERWORTH ---
butterworthQ(order, stage) = qFactor(order % 2)
    with {
        qFactor(0) = 1.0 / (2.0 * cos(((2.0 * stage + 1) *
        (ma.PI / (order * 2.0)))));
        qFactor(1) = 1.0 / (2.0 * cos(((stage + 1) * (ma.PI / order))));
    };

LPButterworthN(1, cf, x) = LPTPT(cf, x);
LPButterworthN(N, cf, x) = cascade(N % 2)
    with {
        cascade(0) = x : seq(i, N / 2, LPSVF(butterworthQ(N, i), cf));
        cascade(1) = x : LPTPT(cf) : seq(i, (N - 1) / 2,
        LPSVF(butterworthQ(N, i), cf));
    };

HPButterworthN(1, cf, x) = HPTPT(cf, x);
HPButterworthN(N, cf, x) = cascade(N % 2)
    with {
        cascade(0) = x : seq(i, N / 2, HPSVF(butterworthQ(N, i), cf));
        cascade(1) = x : HPTPT(cf) : seq(i, (N - 1) /
        2, HPSVF(butterworthQ(N, i), cf));
    };
